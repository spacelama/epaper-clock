/*
  NTP-TZ-DST (v2)
  NetWork Time Protocol - Time Zone - Daylight Saving Time

  This example shows:
  - how to read and set time
  - how to set timezone per country/city
  - how is local time automatically handled per official timezone definitions
  - how to change internal sntp start and update delay
  - how to use callbacks when time is updated

  This example code is in the public domain.
*/

// This database is autogenerated from IANA timezone database
//    https://www.iana.org/time-zones
// and can be updated on demand in this repository
#include <time.h>
#include <WiFi.h>
#include "template.h"
#include <time.h>                       // time() ctime()
#include <sys/time.h>                   // struct timeval
//#include <sntp.h>                       // sntp_servermode_dhcp()
//#include <coredecls.h>                  // settimeofday_cb()
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <RTClib.h>
#include "Adafruit_LEDBackpack.h"
#include <WebServer.h>

String CODE_VERSION = "$Revision: 1.9 $";
WebServer server(80);

// "TZ_" macros follow DST change across seasons without source code change
// check for your nearest city in TZ.h

// pull from TZ.h which is not included in esp32 (plus also, we don't want the PSTR so we can later use the value derived):
#define TZ_Australia_Melbourne        "AEST-10AEDT,M10.1.0,M4.1.0/3"
// example of a timezone with a variable Daylight-Saving-Time:
// demo: watch automatic time adjustment on Summer/Winter change (DST)
#define MYTZ TZ_Australia_Melbourne

timeval tv;
struct timezone tz;
timespec tp;
time_t tnow;

time_t tlast_ntp_sync = 0;

// Set to false to display time in 12 hour format, or true to use 24 hour:
#define TIME_24_HOUR      true

// I2C address of the display.  Stick with the default address of 0x70
// unless you've changed the address jumpers on the back of the display.
#define DISPLAY_ADDRESS   0x70


// Create display and DS1307 objects.  These are global variables that
// can be accessed from both the setup and loop function below.
//FIXME: Adafruit_7segment clockDisplay = Adafruit_7segment();

RTC_DS1307 rtc = RTC_DS1307();

// Remember where in either a rotary or binary blink pattern we currently are
int blinkPatternIndex = 0;

// Keep track of the hours, minutes, seconds displayed by the clock.
// Start off at 0:00:00 as a signal that the time should be read from
// the DS1307 to initialize it.
int hours = 0;
int minutes = 0;
int seconds = 0;

int direction = 0;
int count_h = 0;
int count_m = 0;
int count_s = 0;

// OPTIONAL: change SNTP startup delay
// a weak function is already defined and returns 0 (RFC violation)
// it can be redefined:
//uint32_t sntp_startup_delay_MS_rfc_not_less_than_60000 ()
//{
//    //info_sntp_startup_delay_MS_rfc_not_less_than_60000_has_been_called = true;
//    return 60000; // 60s (or lwIP's original default: (random() % 5000))
//}

// OPTIONAL: change SNTP update delay
// a weak function is already defined and returns 1 hour
// it can be redefined:
//uint32_t sntp_update_delay_MS_rfc_not_less_than_15000 ()
//{
//    //info_sntp_update_delay_MS_rfc_not_less_than_15000_has_been_called = true;
//    return 15000; // 15s
//}

String text;

struct tm timeinfo_wrapper;

void http_gettime() {
    String content = asctime(localtime(&tnow)); // formated local time

    struct tm *now = localtime(&tnow);

    char time[256];
    sprintf(time,"isdst:%i ; %02i:%02i:%02i\n",
            now->tm_isdst,
            now->tm_hour,now->tm_min,now->tm_sec);
    
    server.send(200, "text/html", content+time);
}

void http_setbright() {
    String content;
    uint8_t bright=255;
    if(server.hasArg("bright")) {
        bright = server.arg("bright").toInt();
    }
//FIXME: adjust the frontlight brightness with this (also want to put it on a timer that knows about sunset/sunrise time, or a light sensor)     clockDisplay.setBrightness(bright);
    content="Setting brightness to: "+String(bright)+"\n";;
    server.send(200, "text/html", content);
}

void http_count() {
    char content[80]="";
    int time=0;
    char *direction_str;
    if(server.hasArg("down")) {
        time = server.arg("down").toInt();
        direction = -1;
        direction_str = "down";
    } else if(server.hasArg("up")) {
        time = server.arg("up").toInt();
        direction = 1;
        direction_str = "up";
    } else {
        server.send(200, "text/html", "No up or down parameter in sec supplied\n");
        return;
    }

    count_h = time / 3600;
    count_m = (time / 60) % 60;
    count_s = time % 60;

    snprintf(content,80,"Setting count%s to: %02d:%02d:%02d\n", direction_str, count_h,count_m,count_s);
    server.send(200, "text/html", content);
}

void http_clear() {
    String content;
    direction = 0;
    count_h = count_m = count_s = 0;
    text = "";
    content="Clearing custom displays\n";;
    server.send(200, "text/html", content);
}

void http_settext() {
    String content;
    if(server.hasArg("text")) {
        text = server.arg("text");
    } else {
        server.send(200, "text/html", "No text parameter supplied\n");
        return;
    }
    content="Setting text to: "+text+"\n";
    server.send(200, "text/html", content);
}

void rotaryBlink() {
        // Blink the colon by flipping its value every loop iteration
        // (which happens every second).

//        blinkColon = !blinkColon;
//        clockDisplay.drawColon(blinkColon);
        //000010 ; 0x02 = normal colon
        //000111 ; 0x07 = normal colon and top left dot
        //001000 ; 0x08 = bottom left dot
        //001010 ; 0x0a = normal colon and bottom left dot
        //001100 ; 0x0c = left colon
        //001110 ; 0x0e = both colons
        //010000 ; 0x10 = top right top
        //010110 ; 0x16 = all but bottom left dot
        //011110 ; 0x1E = all dots (no, I don't know why 5 1's aren't lit up)
//        clockDisplay.drawColon(blinkColon,2,0b011110);
//        clockDisplay.drawColon(!blinkColon,2,0x4);

    Serial.println("Rotaryblink()");
    blinkPatternIndex++;
    if (blinkPatternIndex > 3) {
        blinkPatternIndex = 0;
    }
    uint8_t colon_bits = 2<<(blinkPatternIndex);
    Serial.printf("colon_bits: 0x%x\n",colon_bits);
//FIXME:     clockDisplay.writeDigitRaw(2,colon_bits);
}

void blink() {
    blinkPatternIndex++;
    if (blinkPatternIndex > 1) {
        blinkPatternIndex = 0;
    }
//FIXME:     clockDisplay.drawColon(blinkPatternIndex);
}

String http_uptime_stub() {
    return "";
}

// callback function that is called whenever time is set could
// potentially be used to update RTC.  Looks like it might be called
// once per hour by default whenever actively synced, but FIXME: want
// to verify what happens when lose sync and before connection made in
// first place
void time_is_set_scheduled() {
    Serial.println("------------------ settimeofday() was called ------------------");
    tlast_ntp_sync = time(nullptr);
}

void setup_stub() {

/*  for(int i = 0; i < 10; i++)
    {
    printf("in setup\n");
    delay(500);
    } */

    // set time from RTC
    // Normally you would read the RTC to eventually get a current UTC time_t
    // this is faked for now.
    time_t rtc_time_t = 46800; // fake RTC time for now

    timezone tz = { 0, 0};
    timeval tv = { rtc_time_t, 0};

    // DO NOT attempt to use the timezone offsets
    // The timezone offset code is really broken.
    // if used, then localtime() and gmtime() won't work correctly.
    // always set the timezone offsets to zero and use a proper TZ string
    // to get timezone and DST support.

    // set the time of day and explicitly set the timezone offsets to zero
    // as there appears to be a default offset compiled in that needs to
    // be set to zero to disable it.
    settimeofday(&tv, &tz);

    // set function to call when time is set
    // is called by NTP code when NTP is used
//FIXME:    settimeofday_cb(time_is_set_scheduled);

    // set up TZ string to use a POSIX/gnu TZ string for local timezone
    // TZ string information:
    // https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
//  setenv("TZ", "CST+6CDT,M3.2.0/2,M11.1.0/2", 1);
    // Australia/Melbourne:
    // enable NTP by setting up NTP server(s)
    // up to 3 ntp servers can be specified
    // configTime(tzoffset, dstflg, "ntp-server1", "ntp-server2", "ntp-server3");
    // set both timezone offet and dst parameters to zero 
    // and get real timezone & DST support by using a TZ string
    configTzTime(MYTZ, "au.pool.ntp.org");

    // A summary of the NTP/TZ situtation can be found in this comment here: https://www.reddit.com/r/esp8266/comments/jm35k9/clock_project_automatically_adjusts_for_day_light/gassnzj/
    // const char* TZ_INFO = "GMT+0BST-1,M3.5.0/01:00:00,M10.5.0/02:00:00";
    // const char* ntpServer = "uk.pool.ntp.org";
    // configTime(0, 0, ntpServer);
    // setenv("TZ", TZ_INFO, 1);
    // tzset();
    //
    // NTP tz_info for your location can be found here: https://remotemonitoringsystems.ca/time-zone-abbreviations.php or in TZ.h


    // don't wait, observe time changing when ntp timestamp is received

    Serial.println();

    Serial.println("RTC-Clock-MinExample Example");

//  while (WiFi.status() != WL_CONNECTED) {
//    delay(500);
//    Serial.print(".");
//  }

    server.on("/", http_gettime);
    server.on("/time", http_gettime);
    server.on("/count", http_count);
    server.on("/clear", http_clear);
    server.on("/settext", http_settext);
    server.on("/bright", http_setbright);

    // Setup the display.
//FIXME:     clockDisplay.begin(DISPLAY_ADDRESS);

    // Setup the DS1307 real-time clock.
    rtc.begin();

    // Set the DS1307 clock if it hasn't been set before.
    bool setClockTime = !rtc.isrunning();
    // Alternatively you can force the clock to be set again by
    // uncommenting this line:
    //setClockTime = true;
    if (setClockTime) {
        Serial.println("Setting DS1307 time!");
        // This line sets the DS1307 time to the exact date and time the
        // sketch was compiled:
        rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
        // Alternatively you can set the RTC with an explicit date & time, 
        // for example to set January 21, 2014 at 3am you would uncomment:
        //rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
    }
}

// for testing purpose:
extern "C" int clock_gettime(clockid_t unused, struct timespec *tp);

#define PTM(f,w)                                \
    f(":" #w "=");                              \
    f(tm->tm_##w);

void printTm (const char* what, const tm* tm)
{
    Serial.print(what);
    PTM(Serial.print,isdst); PTM(Serial.print,yday); PTM(Serial.print,wday);
    PTM(Serial.print,year);  PTM(Serial.print,mon);  PTM(Serial.print,mday);
    PTM(Serial.print,hour);  PTM(Serial.print,min);  PTM(Serial.print,sec);
}

void loop_stub()
{
    gettimeofday(&tv, &tz);
    clock_gettime(0, &tp); // also supported by esp8266 code
    tnow = time(nullptr);
    bool fast_blink = false;

    // localtime / gmtime every second change
    static time_t lastv = 0;
    if ((tlast_ntp_sync == 0 || (tnow - tlast_ntp_sync > 86400))) {
        fast_blink=true;
    }
    if (lastv != tv.tv_sec) {
#if 1
        printf("tz_minuteswest: %d, tz_dsttime: %d\n", tz.tz_minuteswest, tz.tz_dsttime);
        printf("gettimeofday() tv.tv_sec : %ld\n", lastv);
        printf("time()            time_t : %ld\n", tnow);
        Serial.println();
#endif

        printf("         ctime: %s", ctime(&tnow)); // print formated local time
        printf(" local asctime: %s", asctime(localtime(&tnow))); // print formated local time
        printf("gmtime asctime: %s", asctime(gmtime(&tnow))); // print formated gm time
	
        // print gmtime and localtime tm members
        printTm("      gmtime", gmtime(&tnow));
        Serial.println();
        printTm("   localtime", localtime(&tnow));
        Serial.println();

        Serial.println();

        struct tm *now = localtime(&tnow);
        hours = now->tm_hour;
        minutes  = now->tm_min;
        seconds  = now->tm_sec;

        // Loop function runs over and over again to implement the clock logic.
  
        // Check if it's the top of the hour and get a new time reading
        // from the DS1307.  This helps keep the clock accurate by fixing
        // any drift.
        /* if (minutes == 0) { */
        /*   // Get the time from the DS1307. */
        /*   DateTime now = rtc.now(); */
        /*   // Print out the time for debug purposes: */
        /*   Serial.print("Read date & time from DS1307: "); */
        /*   Serial.print(now.year(), DEC); */
        /*   Serial.print('/'); */
        /*   Serial.print(now.month(), DEC); */
        /*   Serial.print('/'); */
        /*   Serial.print(now.day(), DEC); */
        /*   Serial.print(' '); */
        /*   Serial.print(now.hour(), DEC); */
        /*   Serial.print(':'); */
        /*   Serial.print(now.minute(), DEC); */
        /*   Serial.print(':'); */
        /*   Serial.print(now.second(), DEC); */
        /*   Serial.println(); */
        /*   // Now set the hours and minutes. */
        /*   hours = now.hour(); */
        /*   minutes = now.minute(); */
        /* } */

        // Show the time on the display by turning it into a numeric
        // value, like 3:30 turns into 330, by multiplying the hour by
        // 100 and then adding the minutes.
        int displayValue;
        int custom_display = false;

        // first work out whether we need to increment/decrement a timer
        if (direction != 0) {
            count_s += direction;
            if (count_s >= 60) {
                count_s=0;
                count_m++;
            }
            if (count_m >= 60) {
                count_m=0;
                count_h++;
            }
            if (count_s < 0) {
                count_s=59;
                count_m--;
            }
            if (count_m < 0) {
                count_m=59;
                count_h--;
            }
            if (count_h < 0) { // time to reset
                count_h = count_m = count_s = direction = 0;
            }
        }
        //then work out whether to display it (alternate every 2
        //seconds between clock and countdown/text)
        if (seconds % 8 >= 4) {
            if (direction) {
                displayValue = count_m * 100 + count_s; // discard hh for now...

//FIXME:                 clockDisplay.print(displayValue, DEC);
                custom_display = true;

                fast_blink = false;
                uint8_t colon_bits = 0x0E;
//FIXME:                 clockDisplay.writeDigitRaw(2,colon_bits);
            } else if (text != "") {
                for (int i=0;i<4;i++) {
                    int d=i;
                    if (d>1) {
                        d++;
                    }
                    char c=text[i];
                    uint8_t enc=0;
                    switch (c) {
                      case 'a': enc=0x77; break;
                      case 'b': enc=0x7c; break;
                      case 'c': enc=0x39; break;
                      case 'd': enc=0x5e; break;
                      case 'e': enc=0x79; break;
                      case 'f': enc=0x71; break;
                      case 'g': enc=0x3d; break;
                      case 'i': enc=0x06; break;
                      case 'l': enc=0x38; break;
                      case 'o': enc=0x3f; break;
                      case 'w': enc=0x4f; break;
                    }
//FIXME:                     clockDisplay.writeDigitRaw(d, enc);
                }
                custom_display = true;

                fast_blink = false;
                uint8_t colon_bits = 0x0E;
//FIXME:                 clockDisplay.writeDigitRaw(2,colon_bits);
            }
        }
        if (!custom_display) {
            displayValue = hours*100 + minutes;

            // Do 24 hour to 12 hour format conversion when required.
            if (!TIME_24_HOUR) {
                // Handle when hours are past 12 by subtracting 12 hours (1200 value).
                if (hours > 12) {
                    displayValue -= 1200;
                }
                // Handle hour 0 (midnight) being shown as 12.
                else if (hours == 0) {
                    displayValue += 1200;
                }
            }

            // Now print the time value to the display.
//FIXME:             clockDisplay.print(displayValue, DEC);

            // Add zero padding when in 24 hour mode and it's midnight.
            // In this case the print function above won't have leading 0's
            // which can look confusing.  Go in and explicitly add these zeros.
            if (TIME_24_HOUR && hours == 0) {
                // Pad hour 0.
//FIXME:                 clockDisplay.writeDigitNum(1, 0);
                // Also pad when the 10's minute is 0 and should be padded.
                if (minutes < 10) {
//FIXME:                     clockDisplay.writeDigitNum(3, 0);
                }
            }

            if ((tlast_ntp_sync == 0 || (tnow - tlast_ntp_sync > 86400))) {
                // Fast blink already handled outside of loop
            } else if (tnow - tlast_ntp_sync > 3600) {
                rotaryBlink();
            } else {
                blink();
            }
        }
    }
    if (fast_blink) {
        rotaryBlink();
    }
    if (fast_blink || (lastv != tv.tv_sec)) {
        lastv = tv.tv_sec;
        // Now push out to the display the new values that were set above.
//FIXME:         clockDisplay.writeDisplay();

        // Loop code is finished, it will jump back to the start of the loop
        // function again!
    }
    
    
    delay(100);
}
