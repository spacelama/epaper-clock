/*
  NTP-TZ-DST (v2)
  NetWork Time Protocol - Time Zone - Daylight Saving Time

  This example shows:
  - how to read and set time
  - how to set timezone per country/city
  - how is local time automatically handled per official timezone definitions
  - how to change internal sntp start and update delay
  - how to use callbacks when time is updated

  This example code is in the public domain.
*/

// This database is autogenerated from IANA timezone database
//    https://www.iana.org/time-zones
// and can be updated on demand in this repository
#include <time.h>
#include <WiFi.h>
#include "template.h"
#include <time.h>                       // time() ctime()
#include <sys/time.h>                   // struct timeval
//#include <sntp.h>                       // sntp_servermode_dhcp()
//#include <coredecls.h>                  // settimeofday_cb()
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <RTClib.h>
#include "Adafruit_LEDBackpack.h"
#include <WebServer.h>
#include "epaper-display.h"
#include "temperature.h"

String CODE_VERSION = "$Revision: 1.9 $";
WebServer server(80);

// "TZ_" macros follow DST change across seasons without source code change
// check for your nearest city in TZ.h

// pull from TZ.h which is not included in esp32 (plus also, we don't want the PSTR so we can later use the value derived):
#define TZ_Australia_Melbourne        "AEST-10AEDT,M10.1.0,M4.1.0/3"
// example of a timezone with a variable Daylight-Saving-Time:
// demo: watch automatic time adjustment on Summer/Winter change (DST)
#define MYTZ TZ_Australia_Melbourne
#define NTP_SERVER "au.pool.ntp.org"

timeval tv;
struct timezone tz;
timespec tp;
time_t tnow;

bool delay_startup=false;
unsigned long delay_shutdown;

// Set to false to display time in 12 hour format, or true to use 24 hour:
#define TIME_24_HOUR      true

// I2C address of the display.  Stick with the default address of 0x70
// unless you've changed the address jumpers on the back of the display.
#define DISPLAY_ADDRESS   0x70


// Create display and DS1307 objects.  These are global variables that
// can be accessed from both the setup and loop function below.
//FIXME: Adafruit_7segment clockDisplay = Adafruit_7segment();

RTC_DS1307 rtc = RTC_DS1307();

// Remember where in either a rotary or binary blink pattern we currently are
int blinkPatternIndex = 0;

// Keep track of the hours, minutes, seconds displayed by the clock.
// Start off at 0:00:00 as a signal that the time should be read from
// the DS1307 to initialize it.
int hours = 0;
int minutes = 0;
int seconds = 0;

// OPTIONAL: change SNTP startup delay
// a weak function is already defined and returns 0 (RFC violation)
// it can be redefined:
//uint32_t sntp_startup_delay_MS_rfc_not_less_than_60000 ()
//{
//    //info_sntp_startup_delay_MS_rfc_not_less_than_60000_has_been_called = true;
//    return 60000; // 60s (or lwIP's original default: (random() % 5000))
//}

// OPTIONAL: change SNTP update delay
// a weak function is already defined and returns 1 hour
// it can be redefined:
//uint32_t sntp_update_delay_MS_rfc_not_less_than_15000 ()
//{
//    //info_sntp_update_delay_MS_rfc_not_less_than_15000_has_been_called = true;
//    return 15000; // 15s
//}

String text;

struct tm timeinfo_wrapper;

RTC_DATA_ATTR time_t tlast_ntp_sync = 0;

int last_hour=-1; // doesn't need to preserve over deep sleep because
                  // RTC only wakes us up once per minute anyway, so
                  // we always need to redraw.  This is for when
                  // tightlooping while power is still applied
int last_minute=-1;

void http_gettime() {
    String content = asctime(localtime(&tnow)); // formated local time

    struct tm *now = localtime(&tnow);

    char time[256];
    sprintf(time,"isdst:%i ; %02i:%02i:%02i\n",
            now->tm_isdst,
            now->tm_hour,now->tm_min,now->tm_sec);

    server.send(200, "text/html", content+time);
}

void http_setbright() {
    String content;
    uint8_t bright=255;
    if(server.hasArg("bright")) {
        bright = server.arg("bright").toInt();
    }
//FIXME: adjust the frontlight brightness with this (also want to put it on a timer that knows about sunset/sunrise time, or a light sensor)     clockDisplay.setBrightness(bright);
    content="Setting brightness to: "+String(bright)+"\n";;
    server.send(200, "text/html", content);
}

void showTimeOutOfSync() {
    // Blink the colon by flipping its value every loop iteration
    // (which happens every second).

//        blinkColon = !blinkColon;
//        clockDisplay.drawColon(blinkColon);
    //000010 ; 0x02 = normal colon
    //000111 ; 0x07 = normal colon and top left dot
    //001000 ; 0x08 = bottom left dot
    //001010 ; 0x0a = normal colon and bottom left dot
    //001100 ; 0x0c = left colon
    //001110 ; 0x0e = both colons
    //010000 ; 0x10 = top right top
    //010110 ; 0x16 = all but bottom left dot
    //011110 ; 0x1E = all dots (no, I don't know why 5 1's aren't lit up)
//        clockDisplay.drawColon(blinkColon,2,0b011110);
//        clockDisplay.drawColon(!blinkColon,2,0x4);

    Serial.println("showTimeOutOfSync()");
    blinkPatternIndex++;
    if (blinkPatternIndex > 3) {
        blinkPatternIndex = 0;
    }
    uint8_t colon_bits = 2<<(blinkPatternIndex);
    Serial.printf("colon_bits: 0x%x\n",colon_bits);
//FIXME:     clockDisplay.writeDigitRaw(2,colon_bits);
}

void blink() {
    blinkPatternIndex++;
    if (blinkPatternIndex > 1) {
        blinkPatternIndex = 0;
    }
//FIXME:     clockDisplay.drawColon(blinkPatternIndex);
}

String http_uptime_stub() {
    return "";
}

// callback function that is called whenever time is set could
// potentially be used to update RTC.  Looks like it might be called
// once per hour by default whenever actively synced, but FIXME: want
// to verify what happens when lose sync and before connection made in
// first place
void time_is_set_scheduled(timeval*) {
    Serial.println("------------------ settimeofday() was called ------------------");
    tlast_ntp_sync = time(nullptr);
}

void configureTime(bool resetNtp) {
    // set function to call when time is set
    // is called by NTP code when NTP is used
    sntp_set_time_sync_notification_cb(time_is_set_scheduled);
    if (resetNtp || (tlast_ntp_sync == 0) || (tnow - tlast_ntp_sync > 3600)) {
        configTzTime(MYTZ, NTP_SERVER);
    } else {
        setenv("TZ", MYTZ, 1);
        tzset();
    }
}

void http_start_stub() {
    server.on("/", http_gettime);
    server.on("/time", http_gettime);
    server.on("/bright", http_setbright);
}

void setup_stub() {
//    delay(1000); //Take some time to open up the Serial Monitor

    if (!bootCount) { // if turning on for first time
        configureTime(true);
        delay_startup=true; // wait for NTP
    } else { // if waking from sleep
        configureTime(false);
    }

    Serial.println();

    Serial.println("epaper clock");

//  while (WiFi.status() != WL_CONNECTED) {
//    delay(500);
//    Serial.print(".");
//  }

    // Setup the display.
//FIXME:     clockDisplay.begin(DISPLAY_ADDRESS);

    // Setup the DS1307 real-time clock.
//    rtc.begin();

    // Set the DS1307 clock if it hasn't been set before.
//    bool setClockTime = !rtc.isrunning();
    // Alternatively you can force the clock to be set again by
    // uncommenting this line:
    //setClockTime = true;
//    if (setClockTime) {
//        Serial.println("Setting DS1307 time!");
        // This line sets the DS1307 time to the exact date and time the
        // sketch was compiled:
//        rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
        // Alternatively you can set the RTC with an explicit date & time, 
        // for example to set January 21, 2014 at 3am you would uncomment:
        //rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
//    }

    display_setup();
}

// for testing purpose:
extern "C" int clock_gettime(clockid_t unused, struct timespec *tp);

#define PTM(f,w)                                \
    f(":" #w "=");                              \
    f(tm->tm_##w);

void printTm (const char* what, const tm* tm)
{
    Serial.print(what);
    PTM(Serial.print,isdst); PTM(Serial.print,yday); PTM(Serial.print,wday);
    PTM(Serial.print,year);  PTM(Serial.print,mon);  PTM(Serial.print,mday);
    PTM(Serial.print,hour);  PTM(Serial.print,min);  PTM(Serial.print,sec);
}

void loop_stub()
{
    char time_string[] = "00:00";
    char temp_string[] = "----";
    float temp=-127;

    gettimeofday(&tv, &tz);
    clock_gettime(0, &tp); // also supported by esp8266 code
    tnow = time(nullptr);
    bool fast_blink = false;

    bool power_isnt_connected=(tnow - tlast_ntp_sync) > 10; // FIXME: detect power connected or on battery power

    // localtime / gmtime every second change
    static time_t lastv = 0;
    if ((tlast_ntp_sync == 0 || (tnow - tlast_ntp_sync > 86400))) {
        fast_blink=true;
    }

    struct tm *now = localtime(&tnow);
    hours = now->tm_hour;
    minutes  = now->tm_min;
    seconds  = now->tm_sec;

    if (!tlast_ntp_sync && delay_startup) {
        Serial.printf ("Waiting for ntp to set time: tnow, millis=%d, %d\n", tnow, millis());
        delay(100);
        return;
    }

    minutes = 0 ; // FIXME: need to test what's happening when minutes == 0
    if (lastv != tv.tv_sec) {
        configureTime(false);

#if 1
        Serial.printf("time()=%d, tlast_ntp_sync=%d, (tnow - tlast_ntp_sync)=%d\n", tnow, tlast_ntp_sync, tnow - tlast_ntp_sync);
#endif

//        printf("         ctime: %s", ctime(&tnow)); // print formated local time
        printf(" local asctime: %s", asctime(localtime(&tnow))); // print formated local time
        printf("gmtime asctime: %s", asctime(gmtime(&tnow))); // print formated gm time
	
        // print gmtime and localtime tm members
//        printTm("      gmtime", gmtime(&tnow));
//        Serial.println();
        printTm("   localtime", localtime(&tnow));
        Serial.println();

        Serial.println();

        // Loop function runs over and over again to implement the clock logic.

        // Check if it's the top of the hour and get a new time reading
        // from the DS1307.  This helps keep the clock accurate by fixing
        // any drift.
        /* if (minutes == 0) { */
        /*   // Get the time from the DS1307. */
        /*   DateTime now = rtc.now(); */
        /*   // Print out the time for debug purposes: */
        /*   Serial.print("Read date & time from DS1307: "); */
        /*   Serial.print(now.year(), DEC); */
        /*   Serial.print('/'); */
        /*   Serial.print(now.month(), DEC); */
        /*   Serial.print('/'); */
        /*   Serial.print(now.day(), DEC); */
        /*   Serial.print(' '); */
        /*   Serial.print(now.hour(), DEC); */
        /*   Serial.print(':'); */
        /*   Serial.print(now.minute(), DEC); */
        /*   Serial.print(':'); */
        /*   Serial.print(now.second(), DEC); */
        /*   Serial.println(); */
        /*   // Now set the hours and minutes. */
        /*   hours = now.hour(); */
        /*   minutes = now.minute(); */
        /* } */

        bool update_display=false;
        if (last_minute != minutes) {
            temp = readDSTemperatureC();

            if(temp == -127.00) {
                Serial.println("Failed to read from DS18B20 sensor");
            } else {
                Serial.print("Temperature Celsius: ");
                sprintf(temp_string, "%.1f",temp);
            }

            sprintf(time_string, "%02d:%02d", hours, minutes);

            // Now print the time value to the display.
            display_time(time_string, temp_string);
            update_display=true;
        }

        if ((tlast_ntp_sync == 0 || (tnow - tlast_ntp_sync > 86400))) {
            // Fast blink already handled outside of loop
        } else if (tnow - tlast_ntp_sync > 3600) {
            showTimeOutOfSync();  // FIXME: handle this within main display routine
//            update_display=true;
        } else {
            blink();
        }
        if (fast_blink) {
            showTimeOutOfSync();
        }
        if (fast_blink || (lastv != tv.tv_sec)) {
            lastv = tv.tv_sec;
            // Now push out to the display the new values that were set above.
//FIXME:         clockDisplay.writeDisplay();

            // Loop code is finished, it will jump back to the start of the loop
            // function again!
        }
        if ((minutes == 0) && power_isnt_connected && !delay_shutdown) {  // prior to deep sleep, we'd say: last_hour != hours
            if (update_display) {
                Serial.println("Full updating display");
                display_fullupdate();
            }
            delay_shutdown=millis() + 5000; // make sure display has fully refreshed, and give time for ntp to recieve responses
            next_boot_need_wifi = true;
        } else {
            if (update_display) {
                Serial.println("Partial updating display");
                display_partialupdate();
            }
        }

        last_hour=hours;
        last_minute=minutes;

        display_powerdown();

//        delay(1000); // FIXME: convert this to an RTC sleep
    }
    // FIXME: if time is between sunset and sunrise (can we sense
    // light?), and power is on, light foreground light.
//    Serial.printf("power_isnt_connected=%d,delay_shutdown=%d\n", power_isnt_connected, delay_shutdown);
    if (power_isnt_connected && (
            !delay_shutdown ||
            (millis() > delay_shutdown))) {
        ledBright(led_range);

        int next_min = 60-now->tm_sec;
        Serial.printf("RTC sleeping for %d seconds\n", next_min);

        // deep sleep explained here: https://randomnerdtutorials.com/esp32-deep-sleep-arduino-ide-wake-up-sources/ https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/sleep_modes.html
        esp_sleep_enable_timer_wakeup(1000000LL * next_min);
        Serial.flush();
        // https://old.reddit.com/r/esp32/comments/idinjr/36ma_deep_sleep_in_an_eink_ttgo_t5_v23/ghx00sa/ linked from https://old.reddit.com/r/esp32/comments/idinjr/36ma_deep_sleep_in_an_eink_ttgo_t5_v23/ghx00sa/
        pinMode(13, OUTPUT);
        digitalWrite(13, HIGH);
        gpio_deep_sleep_hold_en();
        esp_deep_sleep_start();
    }
}
